function out = feval(f, xeval, yeval, zeval)
%FEVAL:     Evaluate a CHEBFUN3T object
% This maps the points to the unit cube and applies Clenshaw's algorithm on
% each variable and then uses tensor-matrix multiplication to compute the
% values.
%
% The workflow of this code is as follows:
%
% 1) Check the domain of f. If it is not the unit cube, then map the
% points to the unit cube [-1, +1]^3. This should be done so that
% Clenshaw's algorithm can be applied.
%
% 2) Check whether given points are vectors or tensors (Matrix case is 
% rarely used and if we decided to add this at some point, we can copy from
% chebfun3/feval). If the input points are tensors generated by meshgrid or
% ndgrid, first determine the generating "vector" in each of them. Further 
% operations should be applied only to these vectors and not to the full 
% tensors (unless we have fully unstructured tensors of points).
% 
% 3) Call 1D Clenshaw's algorithm (usually only on the vectors because of 
% Step 2).
%
% 4) Apply tensor-matrix contractions to get the output.
%

% For a tensor of coefficients of size M*N*P and 3 vectors xeval, yeval, 
% and zeval of size n*1, the complexity of this code is O (n*M*N*P).
%
% Steps 1 and 2 can be reordered so that mapping is applied not to the
% whole tensor, but to the generating vectors.

dom = f.domain;

%% Map all the points to [-1, +1]:
% If any of the 3 domains are not [-1, +1], then we need to map points in
% the corresponding domain [a, b] to [-1, +1] so that Clenshaw's algorithm 
% can be accurately applied. We are naiively following the work-flow 1D 
% Chebfun classes have.

% Map x coordinate of points to [-1, 1]:
if ( ~all(dom(1:2) == [-1, 1]) )
    % Create the linear map required in the 1st variable.
    linMap1 = bndfun.createMap(dom(1:2));
    % We just need the inverse part of the linMap1.
    xeval = linMap1.Inv(xeval);
end

% Map y coordinate of points to [-1, 1]:
if ( ~all(dom(3:4) == [-1, 1]) )
    % Create the linear map required in the 2nd variable.
    linMap2 = bndfun.createMap(dom(3:4));
    yeval = linMap2.Inv(yeval);
end

% Map z coordinate of points to [-1, 1]:
if ( ~all(dom(5:6) == [-1, 1]) )
    % Create the linear map required in the 3rd variable.
    linMap3 = bndfun.createMap(dom(5:6));
    zeval = linMap3.Inv(zeval);
end

%%
% %A question is how to apply Clenshaw's algorithm instead of the following direct way ?
% This is done later in this code... Thanks to Anthony !
% Vmx = feval(chebpoly(0:N2-1),xeval);
% Vny = feval(chebpoly(0:M2-1),yeval);
% Vpz = feval(chebpoly(0:P2-1),zeval);
% simple_3D_eval = Vmx*(txm(simple_3D_coeffs,Vpz,3)*Vny.')
% % %simple_3D_eval = txm(txm(txm(simple_3D_coeffs,Vpz,3),Vny,2),Vmx,1)

n = size(xeval);
[M,N,P] = size(f.coeffs);
if ( length(n) == 2 )
    % Inputs are vectors.
    %         Vmx = feval(chebpoly(0:M-1, dom(1:2)),xeval);
    %         Vny = feval(chebpoly(0:N-1, dom(3:4)),yeval);
    %         Vpz = feval(chebpoly(0:P-1, dom(5:6)),zeval);
    % We should NOT use the above 3 lines because "chebpoly" explicitly
    % constructs several chebfun objects each time I call it. This is 
    % potentially expensive, because I am keeping many more information 
    % than what we need just evaluating Chebyshev polynomials (Nick's 
    % comment). The following lines don't construct chebfuns at all and 
    % work just with vectors and matrices.
    % WARNING: This will NOT be very accurate for coordinate points way 
    % outside [-1,1], in which case the above lines provide more accuracy.
    Vmx = chebtech.clenshaw(xeval, eye(M)); 
    Vny = chebtech.clenshaw(yeval, eye(N));
    Vpz = chebtech.clenshaw(zeval, eye(P));
        
    vals3D = zeros(n(1), 1);
    for i = 1: n(1) % number of rows in xeval
        %vals3D(i) = Vmx(i,:)*(txm(coeffs3D,Vpz(i,:),3)*Vny(i,:)');
        %vals3D(i) = Vmx(i,:)*(chebfun3t.txm(coeffs3D,Vpz(i,:),3)*Vny(i,:)');
        vals3D(i) = Vmx(i, :) * (chebfun3t.txm(f.coeffs, Vpz(i, :), 3) * ...
            Vny(i, :)');
    end
    
elseif ( length(n) == 3 )
    % TODO: use ndmis in the line above
    
    % Inputs are tensors.
    % If the evaluation points are derived from ndgrid, then there is a
    % fast way to evaluate a chebfun3. Check for this property. 
    if ( max(max(max(abs(bsxfun(@minus, xeval, xeval(:,1,1)))))) == 0  && ... 
            max(max(max(abs(bsxfun(@minus, yeval, yeval(1,:,1))))) == 0 ) && ... 
            max(max(max(abs(bsxfun(@minus, zeval, zeval(1,1,:))))) == 0 ) )
        xeval = xeval(:,1,1);
        yeval = yeval(1,:,1).';
        zeval = squeeze(zeval(1,1,:));        
        Vmx = chebtech.clenshaw(xeval, eye(M)); 
        Vny = chebtech.clenshaw(yeval, eye(N));
        Vpz = chebtech.clenshaw(zeval, eye(P));
        vals3D = chebfun3t.txm(chebfun3t.txm(chebfun3t.txm(f.coeffs, ...
            Vpz, 3), Vny, 2), Vmx, 1);
                
            
        % Check to see if the input is obtained by meshgrid:
        elseif ( max(max(max(abs(bsxfun(@minus, xeval, xeval(1,:,1)))))) == 0  && ... 
                max(max(max(abs(bsxfun(@minus, yeval, yeval(:,1,1))))) == 0 ) && ... 
                max(max(max(abs(bsxfun(@minus, zeval, zeval(1,1,:))))) == 0 ) )
            
            xeval = xeval(1,:,1).';
            yeval = yeval(:,1,1);
            zeval = squeeze(zeval(1,1,:));            
            
            Vmx = chebtech.clenshaw(xeval, eye(M));
            Vny = chebtech.clenshaw(yeval, eye(N));
            Vpz = chebtech.clenshaw(zeval, eye(P));
            vals3D = chebfun3t.txm(chebfun3t.txm(chebfun3t.txm(f.coeffs, ...
                Vpz, 3), Vny, 2), Vmx, 1);
            vals3D = permute(vals3D, [2 1 3]);
            
    else
        % The inputs are not obtained by ndgrid or meshgrid or ...
        % They are NOT copies of each other and e.g., are random tensors.

    xx1 = chebfun3t.unfold(xeval, 1)';
    yy1 = chebfun3t.unfold(yeval, 1)';
    zz1 = chebfun3t.unfold(zeval, 1)';
    fevalNew = zeros(n(2)*n(3), n(1));
    for i=1:n(1)
        fevalNew(:,i) = feval(f, xx1(:, i), yy1(:, i), zz1(:, i));
    end
    vals3D = reshape(fevalNew', n(1), n(2), n(3));
    
    %         simple_3D_eval = zeros(n);
    %         for i = 1:size(xeval,1)
    %             for j = 1:size(xeval,2)
    %                 for k = 1:size(xeval,3)
    %                     Vmx = feval(chebpoly(0:M-1, dom(1:2)),xeval(i,j,k));
    %                     Vny = feval(chebpoly(0:N-1, dom(3:4)),yeval(i,j,k));
    %                     Vpz = feval(chebpoly(0:P-1, dom(5:6)),zeval(i,j,k));
    %                     vals3D(i,j,k) = chebfun3t.txm(chebfun3t.txm(chebfun3t.txm(coeffs3D,Vpz,3),Vny,2),Vmx,1);
    %                     %vals3D(i,j,k) = Vmx(ii,:)*(txm(coeffs3D,Vpz(ii,:),3)*Vny(ii,:)');
    %                 end
    %             end
    %         end
    
    % Vm = chebpoly(0:M-1, [dom(1), dom(2)]);
    % Vn = chebpoly(0:N-1, [dom(3), dom(4)]); 
    % Vp = chebpoly(0:P-1, [dom(5), dom(6)]);
    %          for i = 1:size(xeval,1)
    %              for j = 1:size(xeval,2)
    %                 for k = 1:size(xeval,3)
    %                     Vmx = Vm(xeval(:,j,k));
    %                     Vny = Vn(yeval(:,j,k));
    %                     Vpz = Vp(zeval(:,j,k));
    %                     vals3D(i,j,k) = chebfun3t.txm(chebfun3t.txm(chebfun3t.txm(coeffs3D,Vpz,3),Vny,2),Vmx,1);
    %                     %vals3D(i,j,k) = Vmx(ii,:)*(txm(coeffs3D,Vpz(ii,:),3)*Vny(ii,:)');
    %                 end
    %             end
    %          end
    end
end
out = vals3D;
end