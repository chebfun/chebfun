function u = expm(L,t,u0)
% EXPM   Exponential semigroup of a linop.
% u = EXPM(L,T,U0) uses matrix exponentiation to propagate an initial condition
% U0 for time T through the differential equation u' = L*u, where L is a linop.
% Formally, the solution is given by u(t) = exp(t*L)*u0, where exp(t*L) is a
% semigroup generated by L. 
%
% The output is a chebmatrix. If T is a vector, then U will have one column for
% each entry of T.
%
% L should have appropriate boundary conditions to make the problem well-posed.
% Those conditions have zero values; i.e. are represented by B*u(t)=0 for a
% linear functional B. 
%
% EXAMPLE: Heat equation
% d = [-1 1];  x = chebfun('x',d);
% D = linop.diff(d);  A = linop( D^2 );  
% A = addlbc(A,0);  A = addrbc(A,0);
% u0 = exp(-20*(x+0.3).^2);  
% t = [0 0.001 0.01 0.1 0.5 1];
% u = expm(A,t,u0);
% colr = zeros(6,3);  colr(:,1) = 0.85.^(0:5)';
% clf, set(gcf,'defaultaxescolororder',colr)
% plot(u,'linewidth',2)
%
% See also LINOP/ADDBC.

% Copyright 2013 by The University of Oxford and The Chebfun Developers.
% See http://www.maths.ox.ac.uk/chebfun/ for Chebfun information.

discType = L.discretizer;
isFun = isFunVariable(L); 

%% Set up the discretisation:
if ( isa(discType, 'function_handle') )
    % Create a discretization object
    disc = discType(L);  
    
    % Merge domains of the operator and the initial condition.
    disc = mergeDomains(disc,u0.domain); 
    
    % Set the allowed discretisation lengths: (TODO: A preference?)
    dimVals = floor(2.^[5 6 7 8 8.5 9 9.5 10 10.5 11]);
    
    dimVals( dimVals < length(u0) ) = [];
    
    % Apply the discretistion dimension on all pieces:
    disc.dimension = repmat(dimVals(1), 1, numel(disc.domain)-1);
    dimVals(1) = [];
else
    % A discretisation is given:
    disc = discType;
    
    % TODO: Check discretisation is valid for the given L and u0!
    
    % Initialise dimVals;
    dimVals = max(disc.dimension);
end

if ( isempty(L.continuity) )
     % Apply continuity conditions:
     disc.source = deriveContinuity(L);
end

% Initialise happiness:
numInt = disc.numIntervals;
isDone = false(1, numInt);

if isa(u0,'chebfun')
    u0 = chebmatrix({u0}); 
end

%% Loop over different times.
allu = chebmatrix({});
for i = 1:length(t)
    
    %% Loop over a finer and finer grid until happy:
    for dim = dimVals
 
        disc.dimension(~isDone) = dim;

        % Discretize the operator (incl. constraints/continuity):
        E = expm(disc,t(i));
        
        % Discretize the initial condition.
        v0 = cellfun(@(x) blockMatrix(disc,x),u0.blocks,'uniform',false);
        v0 = cell2mat(v0);
        
        % Propagate.
        v = E*v0;
        
        % Convert the different components into cells
        u = partition(disc,v);
        
        % Test the happieness of the function pieces:
        [isDone, epsLevel] = testConvergence(disc, u(isFun));
        
        if ( all(isDone) )
            break
        end
        
    end
    
    if ( ~all(isDone) )
        warning('LINOP:expm:NoConverge', ...
            'Matrix exponential may not have converged.')
    end
    
    %% Tidy the solution for output:
    % The variable u is a cell array with the different components of the solution.
    % Because each function component may be piecewise defined, we will loop through
    % one by one.
    %u = mat2fun(disc,u); 
    %for k = find( isFun )
    %    u{k} = disc.toFunction(u{k});
        %     u{k} = simplify(u{k}, epsLevel);
    %end
    
    allu(i) = toFunction(disc,u);
end

u = allu;

end
